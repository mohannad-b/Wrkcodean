import { NextResponse } from "next/server";
import { and, desc, eq } from "drizzle-orm";
import { db } from "@/db";
import { auditLogs, users } from "@/db/schema";
import { can } from "@/lib/auth/rbac";
import { ApiError, handleApiError, requireTenantSession } from "@/lib/api/context";

type RouteParams = {
  params: {
    id: string;
  };
};

type ActivityPayload = {
  id: string;
  action: string;
  displayText: string;
  category: string;
  user: string;
  timestamp: Date;
  metadata?: Record<string, unknown> | null;
};

export async function GET(request: Request, { params }: RouteParams) {
  try {
    const session = await requireTenantSession();

    if (!can(session, "automation:read", { type: "automation_version", tenantId: session.tenantId })) {
      throw new ApiError(403, "Forbidden");
    }

    const url = new URL(request.url);
    const limit = Math.min(Number.parseInt(url.searchParams.get("limit") ?? "50", 10), 100);
    const offset = Math.max(Number.parseInt(url.searchParams.get("offset") ?? "0", 10), 0);

    const logs = await db
      .select({
        id: auditLogs.id,
        action: auditLogs.action,
        userId: auditLogs.userId,
        userName: users.name,
        userEmail: users.email,
        metadata: auditLogs.metadata,
        createdAt: auditLogs.createdAt,
      })
      .from(auditLogs)
      .leftJoin(users, eq(users.id, auditLogs.userId))
      .where(
        and(
          eq(auditLogs.tenantId, session.tenantId),
          eq(auditLogs.resourceType, "automation_version"),
          eq(auditLogs.resourceId, params.id)
        )
      )
      .orderBy(desc(auditLogs.createdAt))
      .limit(limit)
      .offset(offset);

    const activities: ActivityPayload[] = logs.map((log) => {
      const user = log.userName || log.userEmail || "System";
      return {
        id: log.id,
        action: log.action,
        displayText: formatActivityText(log.action, user, log.metadata),
        category: getActivityCategory(log.action),
        user,
        timestamp: log.createdAt,
        metadata: log.metadata,
      };
    });

    return NextResponse.json({ activities });
  } catch (error) {
    return handleApiError(error);
  }
}

function formatActivityText(action: string, userName: string, metadata: Record<string, unknown> | null): string {
  const user = userName || "Someone";
  const toText = (value: unknown) => (typeof value === "string" && value.trim().length > 0 ? value : undefined);
  const statusMeta = (metadata?.status as { from?: string; to?: string }) ?? undefined;
  const stepName = toText(metadata?.stepName);
  const stepNumber = toText(metadata?.stepNumber);

  const actionMap: Record<string, string | ((m: Record<string, unknown> | null) => string)> = {
    "automation.blueprint.drafted": `Blueprint updated by ${user}`,
    "automation.blueprint.step.added": () =>
      stepNumber || stepName
        ? `Step ${stepNumber ? `${stepNumber} ` : ""}${stepName ?? ""} added by ${user}`.trim()
        : `Step added by ${user}`,
    "automation.blueprint.step.deleted": () =>
      stepNumber || stepName
        ? `Step ${stepNumber ? `${stepNumber} ` : ""}${stepName ?? ""} removed by ${user}`.trim()
        : `Step removed by ${user}`,
    "automation.blueprint.step.moved": (m) => {
      const source = toText(m?.sourceStep) ?? stepNumber ?? "a step";
      const target = toText(m?.targetStep) ?? "another step";
      const position = toText(m?.position) ?? "after";
      return `Step ${source} moved ${position} ${target} by ${user}`;
    },
    "automation.blueprint.step.renamed": (m) => {
      const oldName = toText(m?.oldName) ?? stepName ?? "step";
      const newName = toText(m?.newName) ?? "new name";
      return `Step "${oldName}" renamed to "${newName}" by ${user}`;
    },
    "automation.blueprint.step.updated": (m) => {
      const target = toText(m?.targetStep) ?? stepNumber ?? "step";
      return `Step ${target} updated by ${user}`;
    },
    "automation.version.created": `Version created by ${user}`,
    "automation.version.status.changed": () => {
      const from = statusMeta?.from ?? "unknown";
      const to = statusMeta?.to ?? "unknown";
      return `Version status changed from ${from} to ${to} by ${user}`;
    },
    "automation.version.update": `Version details updated by ${user}`,
    "automation.quote.generated": `Quote generated by ${user}`,
    "automation.quote.sent": `Quote sent to client by ${user}`,
    "automation.quote.accepted": `Quote accepted`,
    "automation.quote.rejected": `Quote rejected`,
    "automation.task.created": (m) => `Task "${toText(m?.taskName) ?? "Untitled"}" created by ${user}`,
    "automation.task.completed": (m) => `Task "${toText(m?.taskName) ?? "Untitled"}" completed by ${user}`,
    "automation.task.assigned": (m) =>
      `Task "${toText(m?.taskName) ?? "Untitled"}" assigned to ${toText(m?.assignee) ?? "someone"} by ${user}`,
    "automation.build.requested": `Build requested by ${user}`,
    "automation.build.started": `Build started`,
    "automation.build.completed": `Build completed`,
    "automation.build.failed": (m) => {
      const error = toText(m?.error);
      return `Build failed${error ? ` (${error})` : ""}`;
    },
    "automation.file.uploaded": (m) => `File "${toText(m?.fileName) ?? "attachment"}" uploaded by ${user}`,
    "automation.message.sent": (m) => {
      const role = (m?.role as string) ?? "system";
      const source = (m?.source as string) ?? "copilot";
      if (source === "admin_note") {
        return `Admin note added by ${user}`;
      }
      if (role === "assistant") {
        return "Copilot replied";
      }
      if (role === "user") {
        return `${user} chatted with Copilot`;
      }
      return `Message sent by ${user}`;
    },
    default: `${action.replace(/\./g, " ")} by ${user}`,
  };

  const formatter = actionMap[action] ?? actionMap.default;
  return typeof formatter === "function" ? formatter(metadata) : formatter;
}

function getActivityCategory(action: string): string {
  if (action.includes("blueprint")) return "blueprint";
  if (action.includes("quote")) return "quote";
  if (action.includes("task")) return "task";
  if (action.includes("build")) return "build";
  if (action.includes("file")) return "file";
  if (action.includes("message")) return "message";
  if (action.includes("version")) return "version";
  return "other";
}


